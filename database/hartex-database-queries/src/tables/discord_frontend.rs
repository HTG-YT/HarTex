// ==================! DO NOT MODIFY !==================
// This file is automatically generated by `hartex-database-typedsql`. Please do not modify this in
// any way.
// ==================! DO NOT MODIFY !==================

use wtx::database::Record as _;
use wtx::database::client::postgres::Record;
pub struct NightlyCachedRoles {
    color: i64,
    mentionable: bool,
    hoist: bool,
    icon: Option<String>,
    flags: i32,
    managed: bool,
    position: i32,
    guild_id: String,
    id: String,
}
impl NightlyCachedRoles {
    #[must_use]
    pub fn color(&self) -> i64 {
        self.color
    }
    #[must_use]
    pub fn mentionable(&self) -> bool {
        self.mentionable
    }
    #[must_use]
    pub fn hoist(&self) -> bool {
        self.hoist
    }
    #[must_use]
    pub fn icon(&self) -> Option<&str> {
        self.icon.as_deref()
    }
    #[must_use]
    pub fn flags(&self) -> i32 {
        self.flags
    }
    #[must_use]
    pub fn managed(&self) -> bool {
        self.managed
    }
    #[must_use]
    pub fn position(&self) -> i32 {
        self.position
    }
    #[must_use]
    pub fn guild_id(&self) -> &str {
        self.guild_id.as_str()
    }
    #[must_use]
    pub fn id(&self) -> &str {
        self.id.as_str()
    }
}
impl<'exec, E: From<wtx::Error>> TryFrom<Record<'exec, E>> for NightlyCachedRoles
where
    crate::result::Error: From<E>,
{
    type Error = crate::result::Error;
    fn try_from(record: Record<'exec, E>) -> crate::result::Result<Self> {
        Ok(Self {
            color: record.decode("color")?,
            mentionable: record.decode("mentionable")?,
            hoist: record.decode("hoist")?,
            icon: record.decode_opt("icon")?,
            flags: record.decode("flags")?,
            managed: record.decode("managed")?,
            position: record.decode("position")?,
            guild_id: record.decode("guild_id")?,
            id: record.decode("id")?,
        })
    }
}
pub struct NightlyCachedMembers {
    flags: i64,
    nick: Option<String>,
    guild_id: String,
    user_id: String,
    roles: Vec<String>,
    joined_at: Option<chrono::DateTime<chrono::offset::Utc>>,
}
impl NightlyCachedMembers {
    #[must_use]
    pub fn flags(&self) -> i64 {
        self.flags
    }
    #[must_use]
    pub fn nick(&self) -> Option<&str> {
        self.nick.as_deref()
    }
    #[must_use]
    pub fn guild_id(&self) -> &str {
        self.guild_id.as_str()
    }
    #[must_use]
    pub fn user_id(&self) -> &str {
        self.user_id.as_str()
    }
    #[must_use]
    pub fn roles(&self) -> &[String] {
        self.roles.as_slice()
    }
    #[must_use]
    pub fn joined_at(&self) -> Option<chrono::DateTime<chrono::offset::Utc>> {
        self.joined_at
    }
}
impl<'exec, E: From<wtx::Error>> TryFrom<Record<'exec, E>> for NightlyCachedMembers
where
    crate::result::Error: From<E>,
{
    type Error = crate::result::Error;
    fn try_from(record: Record<'exec, E>) -> crate::result::Result<Self> {
        Ok(Self {
            flags: record.decode("flags")?,
            nick: record.decode_opt("nick")?,
            guild_id: record.decode("guild_id")?,
            user_id: record.decode("user_id")?,
            roles: record.decode("roles")?,
            joined_at: record.decode_opt("joined_at")?,
        })
    }
}
pub struct NightlyCachedGuilds {
    default_message_notifications: i16,
    features: Vec<String>,
    large: bool,
    mfa_level: i16,
    id: String,
    name: String,
    premium_tier: i16,
    owner_id: String,
    icon: Option<String>,
    verification_level: i16,
    explicit_content_filter: i16,
    premium_subscription_count: Option<i64>,
}
impl NightlyCachedGuilds {
    #[must_use]
    pub fn default_message_notifications(&self) -> i16 {
        self.default_message_notifications
    }
    #[must_use]
    pub fn features(&self) -> &[String] {
        self.features.as_slice()
    }
    #[must_use]
    pub fn large(&self) -> bool {
        self.large
    }
    #[must_use]
    pub fn mfa_level(&self) -> i16 {
        self.mfa_level
    }
    #[must_use]
    pub fn id(&self) -> &str {
        self.id.as_str()
    }
    #[must_use]
    pub fn name(&self) -> &str {
        self.name.as_str()
    }
    #[must_use]
    pub fn premium_tier(&self) -> i16 {
        self.premium_tier
    }
    #[must_use]
    pub fn owner_id(&self) -> &str {
        self.owner_id.as_str()
    }
    #[must_use]
    pub fn icon(&self) -> Option<&str> {
        self.icon.as_deref()
    }
    #[must_use]
    pub fn verification_level(&self) -> i16 {
        self.verification_level
    }
    #[must_use]
    pub fn explicit_content_filter(&self) -> i16 {
        self.explicit_content_filter
    }
    #[must_use]
    pub fn premium_subscription_count(&self) -> Option<i64> {
        self.premium_subscription_count
    }
}
impl<'exec, E: From<wtx::Error>> TryFrom<Record<'exec, E>> for NightlyCachedGuilds
where
    crate::result::Error: From<E>,
{
    type Error = crate::result::Error;
    fn try_from(record: Record<'exec, E>) -> crate::result::Result<Self> {
        Ok(Self {
            default_message_notifications: record
                .decode("default_message_notifications")?,
            features: record.decode("features")?,
            large: record.decode("large")?,
            mfa_level: record.decode("mfa_level")?,
            id: record.decode("id")?,
            name: record.decode("name")?,
            premium_tier: record.decode("premium_tier")?,
            owner_id: record.decode("owner_id")?,
            icon: record.decode_opt("icon")?,
            verification_level: record.decode("verification_level")?,
            explicit_content_filter: record.decode("explicit_content_filter")?,
            premium_subscription_count: record.decode_opt("premium_subscription_count")?,
        })
    }
}
pub struct NightlyGuildConfigurations {
    enabled_plugins: Vec<String>,
    guild_id: String,
}
impl NightlyGuildConfigurations {
    #[must_use]
    pub fn enabled_plugins(&self) -> &[String] {
        self.enabled_plugins.as_slice()
    }
    #[must_use]
    pub fn guild_id(&self) -> &str {
        self.guild_id.as_str()
    }
}
impl<'exec, E: From<wtx::Error>> TryFrom<Record<'exec, E>> for NightlyGuildConfigurations
where
    crate::result::Error: From<E>,
{
    type Error = crate::result::Error;
    fn try_from(record: Record<'exec, E>) -> crate::result::Result<Self> {
        Ok(Self {
            enabled_plugins: record.decode("enabled_plugins")?,
            guild_id: record.decode("guild_id")?,
        })
    }
}
pub struct NightlyCachedUsers {
    discriminator: String,
    avatar: Option<String>,
    bot: bool,
    global_name: Option<String>,
    id: String,
    name: String,
}
impl NightlyCachedUsers {
    #[must_use]
    pub fn discriminator(&self) -> &str {
        self.discriminator.as_str()
    }
    #[must_use]
    pub fn avatar(&self) -> Option<&str> {
        self.avatar.as_deref()
    }
    #[must_use]
    pub fn bot(&self) -> bool {
        self.bot
    }
    #[must_use]
    pub fn global_name(&self) -> Option<&str> {
        self.global_name.as_deref()
    }
    #[must_use]
    pub fn id(&self) -> &str {
        self.id.as_str()
    }
    #[must_use]
    pub fn name(&self) -> &str {
        self.name.as_str()
    }
}
impl<'exec, E: From<wtx::Error>> TryFrom<Record<'exec, E>> for NightlyCachedUsers
where
    crate::result::Error: From<E>,
{
    type Error = crate::result::Error;
    fn try_from(record: Record<'exec, E>) -> crate::result::Result<Self> {
        Ok(Self {
            discriminator: record.decode("discriminator")?,
            avatar: record.decode_opt("avatar")?,
            bot: record.decode("bot")?,
            global_name: record.decode_opt("global_name")?,
            id: record.decode("id")?,
            name: record.decode("name")?,
        })
    }
}
pub struct NightlyCachedEmojis {
    guild_id: String,
    name: String,
    id: String,
    animated: bool,
    managed: bool,
}
impl NightlyCachedEmojis {
    #[must_use]
    pub fn guild_id(&self) -> &str {
        self.guild_id.as_str()
    }
    #[must_use]
    pub fn name(&self) -> &str {
        self.name.as_str()
    }
    #[must_use]
    pub fn id(&self) -> &str {
        self.id.as_str()
    }
    #[must_use]
    pub fn animated(&self) -> bool {
        self.animated
    }
    #[must_use]
    pub fn managed(&self) -> bool {
        self.managed
    }
}
impl<'exec, E: From<wtx::Error>> TryFrom<Record<'exec, E>> for NightlyCachedEmojis
where
    crate::result::Error: From<E>,
{
    type Error = crate::result::Error;
    fn try_from(record: Record<'exec, E>) -> crate::result::Result<Self> {
        Ok(Self {
            guild_id: record.decode("guild_id")?,
            name: record.decode("name")?,
            id: record.decode("id")?,
            animated: record.decode("animated")?,
            managed: record.decode("managed")?,
        })
    }
}
